---
title: 同步和异步，进程，线程和协程之间的区别和联系
date: 2021-06-05 15:49:35
categories: python基础知识
tags: [python基础知识, 面试集锦, ] #文章标签，可空，多标签请用格式，注意:后面有个空格

---

同步和异步，进程，线程和协程之间的区别和联系

<!--more-->



# 同步和异步，进程，线程和协程之间的区别和联系



**同步和异步、阻塞和非阻塞**

```
异步： 多任务， 多个任务之间执行没有先后顺序，可以同时运行，执行的先后顺序不会有什么影响，存在的多条运行主线
同步： 多任务， 多个任务之间执行的时候要求有先后顺序，必须一个先执行完成之后，另一个才能继续执行， 只有一个主线
阻塞：从调用者的角度出发，如果在调用的时候，被卡住，不能再继续向下运行，需要等待，就说是阻塞
非阻塞： 从调用者的角度出发， 如果在调用的时候，没有被卡住，能够继续向下运行，无需等待，就说是非阻塞
```

**1）同步、异步**

```
函数或方法被调用的时候，调用者是否得到最终的结果。

直接得到最终结果的结果，就是同步调用。（打饭模型，打饭不打好不走开，直到打饭给我后才离开）
不直接得到的最终的结果，就是异步调用。（打饭，不会一直等着，会时不时的过来看看，打完了把饭拿走，异步不保证多长时间打完了饭）
```

**2）阻塞、非阻塞：**

```
函数或方法调用的时候，是否立即返回。

立即返回就是非阻塞调用。
不立即返回就是阻塞调用。
```

**3）区别：**

```
同步、异步，与阻塞、非阻塞不相关。
同步、异步强调的是结果。阻塞和非阻塞强调的是时间，是否等待。
同步与异步区别在于：调用者是否得到了想要的最终结果。
同步就是一直要执行到返回最终结果。异步就是直接返回了，但是返回的不是最终的结果，调用者不能通过这种调用得到结果，还要通过被调用者，使用其他方式通知调用者，来取回最终结果。
阻塞与非阻塞的区别在于，调用者是否还能干其他的事情。
阻塞，调用者只能干等。非阻塞，调用者可以先忙一会别的，不用一直等。
```

**4）联系：**

```
同步阻塞：调用者阻塞，直到等到拿到最终结果。（打饭模型，什么事情也不敢，就等着打饭，打饭是结果，什么也不干，一直在等着，同步加阻塞）
同步非阻塞：（等着打饭，但是可以玩会手机，看看电视，打饭是结果，但是不用一直在等着）
异步阻塞：（我要打饭，你说等着较好，并没有返回饭给我，我啥事不干，就干等着饭好了叫我）
异步非阻塞：回调的话。（我要打饭，你说等较好，并没有返回饭给我，可以在旁边看看电视，玩玩手机，饭好了叫我）

```

## **进程、线程和协程之间的区别和联系**

## **定义**

进程: 一个运行起来的程序或者软件叫做进程，进程是操作系统分配资源的 基本单位
线程：指进程内的一个执行单元,也是进程内的可调度实体。
协程：是一种程序组件，是由子例程（过程、函数、例程、方法、子程序）的概念泛化而来的，子例程只有一个入口点且只返回一次，而协程允许多个入口点，可以在指定位置挂起和恢复执行。

## 区别

进程是资源分配的最小单位,线程是CPU调度的最小单位.
进程是操作系统资源分配的单位
线程是CPU调度的单位
进程切换需要的资源最大，效率很低
线程切换需要的资源一般，效率一般
协程切换需要资源很小，效率高

## 线程与进程的区别

同一个进程中的线程共享同一内存空间，但是进程之间是独立的。
同一个进程中的所有线程的数据是共享的（进程通讯），进程之间的数据是独立的。
对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。
一个进程至少有一个线程
同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理(队列)来实现
创建新的线程很容易，但是创建新的进程需要对父进程做一次复制。
一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程。
线程启动速度快，进程启动速度慢（但是两者运行速度没有可比性）。

## 协程与线程的比较

一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。
线程进程都是同步机制，而协程则是异步
协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态



**代码demo：**


```python
import time
import queue
def consumer(name):
    print("%s准备开始吃包子啦..." % name)
    while True:
        new_baozi = yield
        print("[%s] 正在吃包子 %s" % (name,new_baozi))
        #time.sleep(1)

def producer():
    r = con.__next__()
    r = con2.__next__()
    n = 0
    while n < 5:    # 生产者只做5个包子
        n += 1
        print("\033[32;1m[producer]\033[0m做好了新包子 %s" % n )
        time.sleep(1)
        con.send(n)
        con2.send(n)

if __name__ == '__main__':
    # 定义2个消费者、1个生产者
    con = consumer("c1")
    con2 = consumer("c2")
    p = producer()
```

协程介绍： https://zhuanlan.zhihu.com/p/38528865 

参考链接 ： https://blog.csdn.net/DD18203614685/article/details/93226319 